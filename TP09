from math import floor, ceil, gcd

class Fraction:
    """Class representing a fraction and operations on it

    Author : V. Van den Schrieck
    Date : October 2021
    This class allows fraction manipulations through several operations.
    """

    def __init__(self, num=0, den=1):
        """This builds a fraction based on some numerator and denominator.

        PRE : num et den sont chacun un entier
        POST : initialise num, den et la fraction qu'ils composent
        RAISE: si den = 0 ou str : renvoie une exception
        """
        self.num = num
        self.den = den
        self.fraction = f"{self.num}/{self.den}"

        if self.den == 0 :
            raise ZeroDivisionError("Denominator cannot be 0")
        if type(self.num) == str or type(self.den) == str:
            raise TypeError("Numerator and denominator must be strings")






    @property
    def numerator(self):
        return self.num

    @property
    def denominator(self):
        return self.den

    # ------------------ Textual representations ------------------

    def __str__(self):
        """Return a textual representation of the reduced form of the fraction

        PRE : le num et den sont initialisé
        POST : renvoie le num et den sous forme de fraction
        """
        return f"{self.num}/{self.den}"

    def as_mixed_number(self):
        """Return a textual representation of the reduced form of the fraction as a mixed number

        A mixed number is the sum of an integer and a proper fraction

        PRE : la fraction initialisé
        POST : renvoie la fraction sous forme nombre mix
                si le numerateur = 0 alors la fraction = 0
        """

        # Ajuster le calcul de la partie entière
        entier = self.num // self.den
        if self.num < 0 and self.num % self.den != 0:
            entier += 1  # Corriger la partie entière pour les fractions négatives

        reste = abs(self.num - entier * self.den)  # Reste positif

        if reste == 0:  # Si aucun reste, c'est un entier
            return str(entier)

        return f"{entier} {reste}/{self.den}"


    # ------------------ Operators overloading ------------------

    def __add__(self, other):
        """Overloading of the + operator for fractions

         PRE : prend deux fractions
         POST : renvoie l'addition simplifié des deux fractions
                si le résultat final donne numerateur = 0 alors la fraction = 0
         """
    #additionne les deux
        nbr1 = self.den * other.num  #3*2
        nbr2 = self.num * other.den #1*6
        numerateur = nbr1 + nbr2
        denominateur = self.den * other.den

    #simplifie
        diviseur = gcd(numerateur, denominateur)

        numerateur_simplifie = numerateur // diviseur
        denominateur_simplifie = denominateur // diviseur
        if numerateur_simplifie == 0 :
            return f"0"
        else:
            return f"{numerateur_simplifie}/{denominateur_simplifie}"


    def __sub__(self, other):
        """Overloading of the - operator for fractions

        PRE : prend deux fractions
        POST : renvoie le resultat de la soustraction simplifié des deux fractions
                si le résultat final donne numerateur = 0 alors la fraction = 0
        """
        nbr1 = self.den * other.num  # 3*2
        nbr2 = self.num * other.den  # 1*6
        numerateur = nbr1 - nbr2
        denominateur = self.den * other.den

        # simplifie
        diviseur = gcd(numerateur, denominateur)

        numerateur_simplifie = numerateur // diviseur
        denominateur_simplifie = denominateur // diviseur
        if numerateur_simplifie == 0:
            return f"0"
        else:
            return f"{numerateur_simplifie}/{denominateur_simplifie}"

    def __mul__(self, other):
        """Overloading of the * operator for fractions

        PRE : prend deux fractions
        POST : renvoie le resultat de la multiplication simplifié des deux fractions
                si le résultat final donne numerateur = 0 alors la fraction = 0
        """
        numerateur = self.num * other.num
        denominateur = self.den * other.den

        diviseur = gcd(numerateur, denominateur)

        numerateur_simplifie = numerateur // diviseur
        denominateur_simplifie = denominateur // diviseur

        if numerateur_simplifie == 0:
            return f"0"
        else:
            return f"{numerateur_simplifie}/{denominateur_simplifie}"

    def __truediv__(self, other):
        """Overloading of the / operator for fractions

        PRE : prend deux fractions
        POST : renvoie le resultat de la division simplifié des deux fractions
                si le résultat final donne numerateur = 0 alors la fraction = 0
        """
        numerateur = self.num * other.den
        denominateur = self.den * other.num

        diviseur = gcd(numerateur, denominateur)

        numerateur_simplifie = numerateur // diviseur
        denominateur_simplifie = denominateur // diviseur

        if numerateur_simplifie == 0:
            return f"0"
        else:
            return f"{numerateur_simplifie}/{denominateur_simplifie}"

    def __pow__(self, other):
        """
        Overloading of the ** operator for fractions

        PRE:
            - `other` est un entier
        POST:
            - Renvoie une nouvelle fraction qui est la puissance de la fraction actuelle.
            - Si `other` < 0 : calcule l'inverse avant d'élever à la puissance.
            - Si `other` = zéro, renvoie 1/1.
        RAISE:
            - ValueError si la fraction est 0/1 et la puissance est négative .
        """
        if other == 0:
            return Fraction(1, 1)  # Toute fraction non nulle élevée à la puissance 0 est 1.
        if self.num == 0 and other < 0:
            raise ValueError("Cannot raise 0 to a negative power (division by zero).")

        if other > 0:
            return Fraction(self.num ** other, self.den ** other)
        elif other < 0:
            return Fraction(self.den ** abs(other), self.num ** abs(other))

    def __eq__(self, other):
        """Overloading of the == operator for fractions

        PRE:`other` est une fraction ou un entier

        POST: Renvoie `True` si les deux fractions sont égales quand simplifié.
              Renvoie `False` sinon.

        RAISE: 'other' n'est pas une fraction ou un entier
        """
        #si other est un entier
        if isinstance(other, int):
            other = Fraction(other,1)

        # simplifie au max
        gcd_self = gcd(self.num, self.den)
        gcd_other = gcd(other.num, other.den)

        num1 = self.num // gcd_self
        den1 = self.den // gcd_self
        num2 = other.num // gcd_other
        den2 = other.den // gcd_other


        # Comparer les fractions simplifié
        return num1 == num2 and den1 == den2

    def __float__(self):
        """Returns the decimal value of the fraction

        PRE : ?
        POST : ?
        """
        pass

    # TODO : [BONUS] You can overload other operators if you wish (ex : <, >, ...)

    # ------------------ Properties checking ------------------

    def is_zero(self):
        """Check if a fraction's value is 0

        PRE : ?
        POST : ?
        """
        pass

    def is_integer(self):
        """Check if a fraction is integer (ex : 8/4, 3, 2/2, ...)

        PRE : ?
        POST : ?
        """
        pass

    def is_proper(self):
        """Check if the absolute value of the fraction is < 1

        PRE : ?
        POST : ?
        """

    def is_unit(self):
        """Check if a fraction's numerator is 1 in its reduced form

        PRE : ?
        POST : ?
        """
        pass

    def is_adjacent_to(self, other):
        """Check if two fractions differ by a unit fraction

        Two fractions are adjacents if the absolute value of the difference them is a unit fraction

        PRE : ?
        POST : ?
        """
        pass


unQuart = Fraction(1,1)
deuxQuart = Fraction(4,2)
test = unQuart.__eq__(1)
print(test)
